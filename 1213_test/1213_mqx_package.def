-- HEADER --------------------------------------------------------------
-- ---------------------------------------------------------------------
--
--  Copyright (c) 1992-2003 ARC International
--  All rights reserved
--
--  This software embodies materials and concepts which are
--  confidential to ARC International and is made available solely
--  pursuant to the terms of a written license agreement with
--  ARC International.
--
--  File: 1213.def
--
--  Comments:  This file contains an implementation of the RFC 1213 MIB.
--
-- ---------------------------------------------------------------------
-- END -----------------------------------------------------------------

-- Generated by mosy, edit at will
-- Definitions for RFC1213-MIB
mib-2                                   mgmt.1                                                                           
%% DisplayString OCTET
%% PhysAddress OCTET
system                                  mib-2.1                                                                          
interfaces                              mib-2.2                                                                          
-- at                                      mib-2.3                                                                          
ip                                      mib-2.4                                                                          
icmp                                    mib-2.5                                                                          
tcp                                     mib-2.6                                                                          
udp                                     mib-2.7                                                                          
-- egp                                     mib-2.8                                                                          
transmission                            mib-2.10                                                                         
snmp                                    mib-2.11                                                                         
sysDescr                                system.1                                DisplayString   read-only       mandatory   
sysObjectID                             system.2                                OBJECT          read-only       mandatory   
sysUpTime                               system.3                                TimeTicks       read-only       mandatory   
sysContact                              system.4                                DisplayString   read-write      mandatory   
sysName                                 system.5                                DisplayString   read-write      mandatory   
sysLocation                             system.6                                DisplayString   read-write      mandatory   
sysServices                             system.7                                INTEGER         read-only       mandatory   
ifNumber                                interfaces.1                            INTEGER         read-only       mandatory   
ifTable                                 interfaces.2                            SEQUENCE        not-accessible  mandatory   
ifEntry                                 ifTable.1                               SEQUENCE        not-accessible  mandatory   ifIndex
ifIndex                                 ifEntry.1                               INTEGER         read-only       mandatory   
ifDescr                                 ifEntry.2                               DisplayString   read-only       mandatory   
ifType                                  ifEntry.3                               INTEGER         read-only       mandatory   
ifMtu                                   ifEntry.4                               INTEGER         read-only       mandatory   
ifSpeed                                 ifEntry.5                               Gauge           read-only       mandatory   
ifPhysAddress                           ifEntry.6                               PhysAddress     read-only       mandatory   
ifAdminStatus                           ifEntry.7                               INTEGER         read-write      mandatory   
ifOperStatus                            ifEntry.8                               INTEGER         read-only       mandatory   
ifLastChange                            ifEntry.9                               TimeTicks       read-only       mandatory   
ifInOctets                              ifEntry.10                              Counter         read-only       mandatory   
ifInUcastPkts                           ifEntry.11                              Counter         read-only       mandatory   
ifInNUcastPkts                          ifEntry.12                              Counter         read-only       mandatory   
ifInDiscards                            ifEntry.13                              Counter         read-only       mandatory   
ifInErrors                              ifEntry.14                              Counter         read-only       mandatory   
ifInUnknownProtos                       ifEntry.15                              Counter         read-only       mandatory   
ifOutOctets                             ifEntry.16                              Counter         read-only       mandatory   
ifOutUcastPkts                          ifEntry.17                              Counter         read-only       mandatory   
ifOutNUcastPkts                         ifEntry.18                              Counter         read-only       mandatory   
ifOutDiscards                           ifEntry.19                              Counter         read-only       mandatory   
ifOutErrors                             ifEntry.20                              Counter         read-only       mandatory   
ifOutQLen                               ifEntry.21                              Gauge           read-only       mandatory   
ifSpecific                              ifEntry.22                              OBJECT          read-only       mandatory   
-- atTable                                 at.1                                    SEQUENCE        not-accessible  deprecated  
-- atEntry                                 atTable.1                               SEQUENCE        not-accessible  deprecated  atIfIndex atNetAddress
-- atIfIndex                               atEntry.1                               INTEGER         read-write      deprecated  
-- atPhysAddress                           atEntry.2                               PhysAddress     read-write      deprecated  
-- atNetAddress                            atEntry.3                               NetworkAddress  read-write      deprecated  
ipForwarding                            ip.1                                    INTEGER         read-write      mandatory   
ipDefaultTTL                            ip.2                                    INTEGER         read-write      mandatory   
ipInReceives                            ip.3                                    Counter         read-only       mandatory   
ipInHdrErrors                           ip.4                                    Counter         read-only       mandatory   
ipInAddrErrors                          ip.5                                    Counter         read-only       mandatory   
ipForwDatagrams                         ip.6                                    Counter         read-only       mandatory   
ipInUnknownProtos                       ip.7                                    Counter         read-only       mandatory   
ipInDiscards                            ip.8                                    Counter         read-only       mandatory   
ipInDelivers                            ip.9                                    Counter         read-only       mandatory   
ipOutRequests                           ip.10                                   Counter         read-only       mandatory   
ipOutDiscards                           ip.11                                   Counter         read-only       mandatory   
ipOutNoRoutes                           ip.12                                   Counter         read-only       mandatory   
ipReasmTimeout                          ip.13                                   INTEGER         read-only       mandatory   
ipReasmReqds                            ip.14                                   Counter         read-only       mandatory   
ipReasmOKs                              ip.15                                   Counter         read-only       mandatory   
ipReasmFails                            ip.16                                   Counter         read-only       mandatory   
ipFragOKs                               ip.17                                   Counter         read-only       mandatory   
ipFragFails                             ip.18                                   Counter         read-only       mandatory   
ipFragCreates                           ip.19                                   Counter         read-only       mandatory   
ipAddrTable                             ip.20                                   SEQUENCE        not-accessible  mandatory   
ipAddrEntry                             ipAddrTable.1                           SEQUENCE        not-accessible  mandatory   ipAdEntAddr
ipAdEntAddr                             ipAddrEntry.1                           IpAddress       read-only       mandatory   
ipAdEntIfIndex                          ipAddrEntry.2                           INTEGER         read-only       mandatory   
ipAdEntNetMask                          ipAddrEntry.3                           IpAddress       read-only       mandatory   
ipAdEntBcastAddr                        ipAddrEntry.4                           INTEGER         read-only       mandatory   
ipAdEntReasmMaxSize                     ipAddrEntry.5                           INTEGER         read-only       mandatory   
ipRouteTable                            ip.21                                   SEQUENCE        not-accessible  mandatory   
ipRouteEntry                            ipRouteTable.1                          SEQUENCE        not-accessible  mandatory   ipRouteDest
ipRouteDest                             ipRouteEntry.1                          IpAddress       read-write      mandatory   
ipRouteIfIndex                          ipRouteEntry.2                          INTEGER         read-write      mandatory   
ipRouteMetric1                          ipRouteEntry.3                          INTEGER         read-write      mandatory   
ipRouteMetric2                          ipRouteEntry.4                          INTEGER         read-write      mandatory   
ipRouteMetric3                          ipRouteEntry.5                          INTEGER         read-write      mandatory   
ipRouteMetric4                          ipRouteEntry.6                          INTEGER         read-write      mandatory   
ipRouteNextHop                          ipRouteEntry.7                          IpAddress       read-write      mandatory   
ipRouteType                             ipRouteEntry.8                          INTEGER         read-write      mandatory   
ipRouteProto                            ipRouteEntry.9                          INTEGER         read-only       mandatory   
ipRouteAge                              ipRouteEntry.10                         INTEGER         read-write      mandatory   
ipRouteMask                             ipRouteEntry.11                         IpAddress       read-write      mandatory   
ipRouteMetric5                          ipRouteEntry.12                         INTEGER         read-write      mandatory   
ipRouteInfo                             ipRouteEntry.13                         OBJECT          read-only       mandatory   
ipNetToMediaTable                       ip.22                                   SEQUENCE        not-accessible  mandatory   
ipNetToMediaEntry                       ipNetToMediaTable.1                     SEQUENCE        not-accessible  mandatory   ipNetToMediaIfIndex ipNetToMediaNetAddress
ipNetToMediaIfIndex                     ipNetToMediaEntry.1                     INTEGER         read-write      mandatory   
ipNetToMediaPhysAddress                 ipNetToMediaEntry.2                     PhysAddress     read-write      mandatory   
ipNetToMediaNetAddress                  ipNetToMediaEntry.3                     IpAddress       read-write      mandatory   
ipNetToMediaType                        ipNetToMediaEntry.4                     INTEGER         read-write      mandatory   
ipRoutingDiscards                       ip.23                                   Counter         read-only       mandatory   
icmpInMsgs                              icmp.1                                  Counter         read-only       mandatory   
icmpInErrors                            icmp.2                                  Counter         read-only       mandatory   
icmpInDestUnreachs                      icmp.3                                  Counter         read-only       mandatory   
icmpInTimeExcds                         icmp.4                                  Counter         read-only       mandatory   
icmpInParmProbs                         icmp.5                                  Counter         read-only       mandatory   
icmpInSrcQuenchs                        icmp.6                                  Counter         read-only       mandatory   
icmpInRedirects                         icmp.7                                  Counter         read-only       mandatory   
icmpInEchos                             icmp.8                                  Counter         read-only       mandatory   
icmpInEchoReps                          icmp.9                                  Counter         read-only       mandatory   
icmpInTimestamps                        icmp.10                                 Counter         read-only       mandatory   
icmpInTimestampReps                     icmp.11                                 Counter         read-only       mandatory   
icmpInAddrMasks                         icmp.12                                 Counter         read-only       mandatory   
icmpInAddrMaskReps                      icmp.13                                 Counter         read-only       mandatory   
icmpOutMsgs                             icmp.14                                 Counter         read-only       mandatory   
icmpOutErrors                           icmp.15                                 Counter         read-only       mandatory   
icmpOutDestUnreachs                     icmp.16                                 Counter         read-only       mandatory   
icmpOutTimeExcds                        icmp.17                                 Counter         read-only       mandatory   
icmpOutParmProbs                        icmp.18                                 Counter         read-only       mandatory   
icmpOutSrcQuenchs                       icmp.19                                 Counter         read-only       mandatory   
icmpOutRedirects                        icmp.20                                 Counter         read-only       mandatory   
icmpOutEchos                            icmp.21                                 Counter         read-only       mandatory   
icmpOutEchoReps                         icmp.22                                 Counter         read-only       mandatory   
icmpOutTimestamps                       icmp.23                                 Counter         read-only       mandatory   
icmpOutTimestampReps                    icmp.24                                 Counter         read-only       mandatory   
icmpOutAddrMasks                        icmp.25                                 Counter         read-only       mandatory   
icmpOutAddrMaskReps                     icmp.26                                 Counter         read-only       mandatory   
tcpRtoAlgorithm                         tcp.1                                   INTEGER         read-only       mandatory   
tcpRtoMin                               tcp.2                                   INTEGER         read-only       mandatory   
tcpRtoMax                               tcp.3                                   INTEGER         read-only       mandatory   
tcpMaxConn                              tcp.4                                   INTEGER         read-only       mandatory   
tcpActiveOpens                          tcp.5                                   Counter         read-only       mandatory   
tcpPassiveOpens                         tcp.6                                   Counter         read-only       mandatory   
tcpAttemptFails                         tcp.7                                   Counter         read-only       mandatory   
tcpEstabResets                          tcp.8                                   Counter         read-only       mandatory   
tcpCurrEstab                            tcp.9                                   Gauge           read-only       mandatory   
tcpInSegs                               tcp.10                                  Counter         read-only       mandatory   
tcpOutSegs                              tcp.11                                  Counter         read-only       mandatory   
tcpRetransSegs                          tcp.12                                  Counter         read-only       mandatory   
tcpConnTable                            tcp.13                                  SEQUENCE        not-accessible  mandatory   
tcpConnEntry                            tcpConnTable.1                          SEQUENCE        not-accessible  mandatory   tcpConnLocalAddress tcpConnLocalPort tcpConnRemAddress tcpConnRemPort
tcpConnState                            tcpConnEntry.1                          INTEGER         read-write      mandatory   
tcpConnLocalAddress                     tcpConnEntry.2                          IpAddress       read-only       mandatory   
tcpConnLocalPort                        tcpConnEntry.3                          INTEGER         read-only       mandatory   
tcpConnRemAddress                       tcpConnEntry.4                          IpAddress       read-only       mandatory   
tcpConnRemPort                          tcpConnEntry.5                          INTEGER         read-only       mandatory   
tcpInErrs                               tcp.14                                  Counter         read-only       mandatory   
tcpOutRsts                              tcp.15                                  Counter         read-only       mandatory   
udpInDatagrams                          udp.1                                   Counter         read-only       mandatory   
udpNoPorts                              udp.2                                   Counter         read-only       mandatory   
udpInErrors                             udp.3                                   Counter         read-only       mandatory   
udpOutDatagrams                         udp.4                                   Counter         read-only       mandatory   
udpTable                                udp.5                                   SEQUENCE        not-accessible  mandatory   
udpEntry                                udpTable.1                              SEQUENCE        not-accessible  mandatory   udpLocalAddress udpLocalPort
udpLocalAddress                         udpEntry.1                              IpAddress       read-only       mandatory   
udpLocalPort                            udpEntry.2                              INTEGER         read-only       mandatory   
-- egpInMsgs                               egp.1                                   Counter         read-only       mandatory   
-- egpInErrors                             egp.2                                   Counter         read-only       mandatory   
-- egpOutMsgs                              egp.3                                   Counter         read-only       mandatory   
-- egpOutErrors                            egp.4                                   Counter         read-only       mandatory   
-- egpNeighTable                           egp.5                                   SEQUENCE        not-accessible  mandatory   
-- egpNeighEntry                           egpNeighTable.1                         SEQUENCE        not-accessible  mandatory   egpNeighAddr
-- egpNeighState                           egpNeighEntry.1                         INTEGER         read-only       mandatory   
-- egpNeighAddr                            egpNeighEntry.2                         IpAddress       read-only       mandatory   
-- egpNeighAs                              egpNeighEntry.3                         INTEGER         read-only       mandatory   
-- egpNeighInMsgs                          egpNeighEntry.4                         Counter         read-only       mandatory   
-- egpNeighInErrs                          egpNeighEntry.5                         Counter         read-only       mandatory   
-- egpNeighOutMsgs                         egpNeighEntry.6                         Counter         read-only       mandatory   
-- egpNeighOutErrs                         egpNeighEntry.7                         Counter         read-only       mandatory   
-- egpNeighInErrMsgs                       egpNeighEntry.8                         Counter         read-only       mandatory   
-- egpNeighOutErrMsgs                      egpNeighEntry.9                         Counter         read-only       mandatory   
-- egpNeighStateUps                        egpNeighEntry.10                        Counter         read-only       mandatory   
-- egpNeighStateDowns                      egpNeighEntry.11                        Counter         read-only       mandatory   
-- egpNeighIntervalHello                   egpNeighEntry.12                        INTEGER         read-only       mandatory   
-- egpNeighIntervalPoll                    egpNeighEntry.13                        INTEGER         read-only       mandatory   
-- egpNeighMode                            egpNeighEntry.14                        INTEGER         read-only       mandatory   
-- egpNeighEventTrigger                    egpNeighEntry.15                        INTEGER         read-write      mandatory   
-- egpAs                                   egp.6                                   INTEGER         read-only       mandatory   
snmpInPkts                              snmp.1                                  Counter         read-only       mandatory   
snmpOutPkts                             snmp.2                                  Counter         read-only       mandatory   
snmpInBadVersions                       snmp.3                                  Counter         read-only       mandatory   
snmpInBadCommunityNames                 snmp.4                                  Counter         read-only       mandatory   
snmpInBadCommunityUses                  snmp.5                                  Counter         read-only       mandatory   
snmpInASNParseErrs                      snmp.6                                  Counter         read-only       mandatory   
snmpInTooBigs                           snmp.8                                  Counter         read-only       mandatory   
snmpInNoSuchNames                       snmp.9                                  Counter         read-only       mandatory   
snmpInBadValues                         snmp.10                                 Counter         read-only       mandatory   
snmpInReadOnlys                         snmp.11                                 Counter         read-only       mandatory   
snmpInGenErrs                           snmp.12                                 Counter         read-only       mandatory   
snmpInTotalReqVars                      snmp.13                                 Counter         read-only       mandatory   
snmpInTotalSetVars                      snmp.14                                 Counter         read-only       mandatory   
snmpInGetRequests                       snmp.15                                 Counter         read-only       mandatory   
snmpInGetNexts                          snmp.16                                 Counter         read-only       mandatory   
snmpInSetRequests                       snmp.17                                 Counter         read-only       mandatory   
snmpInGetResponses                      snmp.18                                 Counter         read-only       mandatory   
snmpInTraps                             snmp.19                                 Counter         read-only       mandatory   
snmpOutTooBigs                          snmp.20                                 Counter         read-only       mandatory   
snmpOutNoSuchNames                      snmp.21                                 Counter         read-only       mandatory   
snmpOutBadValues                        snmp.22                                 Counter         read-only       mandatory   
snmpOutGenErrs                          snmp.24                                 Counter         read-only       mandatory   
snmpOutGetRequests                      snmp.25                                 Counter         read-only       mandatory   
snmpOutGetNexts                         snmp.26                                 Counter         read-only       mandatory   
snmpOutSetRequests                      snmp.27                                 Counter         read-only       mandatory   
snmpOutGetResponses                     snmp.28                                 Counter         read-only       mandatory   
snmpOutTraps                            snmp.29                                 Counter         read-only       mandatory   
snmpEnableAuthenTraps                   snmp.30                                 INTEGER         read-write      mandatory   
%%

#include "tcpip.h"
#include "ip_prv.h"
#include "arp_prv.h"
#include "tcp_prv.h"
#include "udp_prv.h"

static uchar IpAddress[4];

uint_32 MIB_get_sysUpTime (pointer dummy)
{ /* Body */
   TIME_STRUCT uptime;
   _time_get_elapsed(&uptime);
   return (uptime.SECONDS * 100) + (uptime.MILLISECONDS / 10);
} /* Endbody */

static uint_32 MIB_set_dispstr
   (
      uchar_ptr _PTR_ dest,
      uchar_ptr       varptr,
      uint_32         varlen
   )
{ /* Body */
   uchar_ptr dispstr = NULL;

   if (varlen) {
      dispstr = _mem_alloc(varlen+1);
      if (!dispstr) {
         return SNMP_ERROR_resourceUnavailable;
      } /* Endif */
      _mem_copy(varptr, dispstr, varlen);
      dispstr[varlen] = '\0';
   } /* Endif */

   if (*dest) {
      _mem_free(*dest);
   } /* Endif */

   *dest = dispstr;
   return SNMP_ERROR_noError;

} /* Endbody */

uint_32 MIB_set_sysContact (pointer dummy, uchar_ptr varptr, uint_32 varlen)
{ /* Body */
   return MIB_set_dispstr(&MIBNODE_sysContact.GET.DISPSTR_PTR, varptr, varlen);
} /* Endbody */

uint_32 MIB_set_sysName (pointer dummy, uchar_ptr varptr, uint_32 varlen)
{ /* Body */
   return MIB_set_dispstr(&MIBNODE_sysName.GET.DISPSTR_PTR, varptr, varlen);
} /* Endbody */

uint_32 MIB_set_sysLocation (pointer dummy, uchar_ptr varptr, uint_32 varlen)
{ /* Body */
   return MIB_set_dispstr(&MIBNODE_sysLocation.GET.DISPSTR_PTR, varptr, varlen);
} /* Endbody */


struct MIB_get_ifNumber_struct {
   uint_32                 current_index;
   IP_CFG_STRUCT_PTR       IP_cfg_ptr;
   IP_ROUTE_DIRECT_PTR     direct;
};

boolean MIB_get_ifNumber_test2
   (
      _ip_address    node_ip,
      _ip_address    node_mask,
      pointer        node_data,
      pointer        data
   )
{ /* Body */
   IP_ROUTE_PTR                  route = node_data;
   struct MIB_get_ifNumber_struct _PTR_ testdata = data;

   /* Check only leaves, which have a DESTIF of LOCALHOST */
   if (route && route->DIRECT &&
      route->DIRECT->DESTIF == testdata->IP_cfg_ptr->IF_LOCALHOST)
   {
      if (testdata->direct == route->DIRECT) {
         testdata->current_index++;
      } /* Endif */

      if (testdata->direct->NETIF == route->DIRECT->NETIF) {
         return TRUE;
      }
   } /* Endif */

   return FALSE;

} /* Endbody */

boolean MIB_get_ifNumber_test1
   (
      _ip_address    node_ip,
      _ip_address    node_mask,
      pointer        node_data,
      pointer        data
   )
{ /* Body */
   IP_ROUTE_PTR                  route = node_data;
   struct MIB_get_ifNumber_struct _PTR_ testdata = data;

   /* Check only leaves, which have a DESTIF of LOCALHOST */
   if (route && route->DIRECT &&
      route->DIRECT->DESTIF == testdata->IP_cfg_ptr->IF_LOCALHOST)
   {
      testdata->direct = route->DIRECT;
      IPRADIX_walk(&testdata->IP_cfg_ptr->ROUTE_ROOT.NODE, MIB_get_ifNumber_test2,
         testdata);
   } /* Endif */

   return FALSE;
} /* Body */

uint_32 MIB_get_ifNumber (pointer dummy)
{ /* Body */
   IP_CFG_STRUCT_PTR                IP_cfg_ptr = RTCS_getcfg(IP);
   struct MIB_get_ifNumber_struct   testdata;

   testdata.current_index  = 0;
   testdata.IP_cfg_ptr     = IP_cfg_ptr;
   testdata.direct         = NULL;

   IPRADIX_walk(&IP_cfg_ptr->ROUTE_ROOT.NODE, MIB_get_ifNumber_test1, &testdata);

   return testdata.current_index;

} /* Endbody */

struct MIB_get_ifif_struct {
   uint_32                 current_index;
   IP_CFG_STRUCT_PTR       IP_cfg_ptr;
   IP_ROUTE_DIRECT_PTR     direct;
   IP_IF_PTR               interface;
   uint_32                 ifindex;
};

boolean MIB_get_ifif_test2
   (
      _ip_address    node_ip,
      _ip_address    node_mask,
      pointer        node_data,
      pointer        data
   )
{ /* Body */
   IP_ROUTE_PTR                     route = node_data;
   struct MIB_get_ifif_struct _PTR_ testdata = data;

   /* Check only leaves, which have a DESTIF of LOCALHOST */
   if (route && route->DIRECT &&
      route->DIRECT->DESTIF == testdata->IP_cfg_ptr->IF_LOCALHOST)
   {
      if (testdata->direct == route->DIRECT) {
         testdata->current_index++;
         if (testdata->ifindex == testdata->current_index) {
            testdata->interface = testdata->direct->NETIF;
            return TRUE;
         } /* Endif */
      } /* Endif */

      if (testdata->direct->NETIF == route->DIRECT->NETIF) {
         return TRUE;
      }
   } /* Endif */

   return FALSE;

} /* Endbody */

boolean MIB_get_ifif_test1
   (
      _ip_address    node_ip,
      _ip_address    node_mask,
      pointer        node_data,
      pointer        data
   )
{ /* Body */
   IP_ROUTE_PTR                     route = node_data;
   struct MIB_get_ifif_struct _PTR_ testdata = data;

   /* Check only leaves, which have a DESTIF of LOCALHOST */
   if (route && route->DIRECT &&
      route->DIRECT->DESTIF == testdata->IP_cfg_ptr->IF_LOCALHOST)
   {
      testdata->direct = route->DIRECT;
      IPRADIX_walk(&testdata->IP_cfg_ptr->ROUTE_ROOT.NODE, MIB_get_ifif_test2,
         testdata);
      if (testdata->interface) {
         return TRUE;
      } /* Endif */
   } /* Endif */

   return FALSE;
} /* Body */

pointer MIB_get_ifif (uint_32 ifindex)
{ /* Body */
   IP_CFG_STRUCT_PTR          IP_cfg_ptr = RTCS_getcfg(IP);
   struct MIB_get_ifif_struct testdata;

   testdata.current_index  = 0;
   testdata.IP_cfg_ptr     = IP_cfg_ptr;
   testdata.direct         = NULL;
   testdata.ifindex        = ifindex;
   testdata.interface      = NULL;

   IPRADIX_walk(&IP_cfg_ptr->ROUTE_ROOT.NODE, MIB_get_ifif_test1, &testdata);

   return testdata.interface;
} /* Endbody */

struct MIB_get_ifIndex_struct {
   uint_32                 current_index;
   IP_CFG_STRUCT_PTR       IP_cfg_ptr;
   IP_ROUTE_DIRECT_PTR     direct;
   IP_IF_PTR               interface;
   uint_32                 ifindex;
};

boolean MIB_get_ifIndex_test2
   (
      _ip_address    node_ip,
      _ip_address    node_mask,
      pointer        node_data,
      pointer        data
   )
{ /* Body */
   IP_ROUTE_PTR                        route = node_data;
   struct MIB_get_ifIndex_struct _PTR_ testdata = data;

   /* Check only leaves, which have a DESTIF of LOCALHOST */
   if (route && route->DIRECT &&
      route->DIRECT->DESTIF == testdata->IP_cfg_ptr->IF_LOCALHOST)
   {
      if (testdata->direct == route->DIRECT) {
         testdata->current_index++;
         if (testdata->interface == testdata->direct->NETIF) {
            testdata->ifindex = testdata->current_index;
            return TRUE;
         } /* Endif */
      } /* Endif */

      if (testdata->direct->NETIF == route->DIRECT->NETIF) {
         return TRUE;
      }
   } /* Endif */

   return FALSE;

} /* Endbody */

boolean MIB_get_ifIndex_test1
   (
      _ip_address    node_ip,
      _ip_address    node_mask,
      pointer        node_data,
      pointer        data
   )
{ /* Body */
   IP_ROUTE_PTR                        route = node_data;
   struct MIB_get_ifIndex_struct _PTR_ testdata = data;

   /* Check only leaves, which have a DESTIF of LOCALHOST */
   if (route && route->DIRECT &&
      route->DIRECT->DESTIF == testdata->IP_cfg_ptr->IF_LOCALHOST)
   {
      testdata->direct = route->DIRECT;
      IPRADIX_walk(&testdata->IP_cfg_ptr->ROUTE_ROOT.NODE, MIB_get_ifIndex_test2,
         testdata);
      if (testdata->ifindex) {
         return TRUE;
      } /* Endif */
   } /* Endif */

   return FALSE;
} /* Body */

uint_32 MIB_get_ifIndex (pointer interface)
{ /* Body */
   IP_CFG_STRUCT_PTR             IP_cfg_ptr = RTCS_getcfg(IP);
   struct MIB_get_ifIndex_struct testdata;

   testdata.current_index  = 0;
   testdata.IP_cfg_ptr     = IP_cfg_ptr;
   testdata.direct         = NULL;
   testdata.ifindex        = 0;
   testdata.interface      = interface;

   IPRADIX_walk(&IP_cfg_ptr->ROUTE_ROOT.NODE, MIB_get_ifIndex_test1, &testdata);

   return testdata.ifindex;
} /* Endbody */

uint_32 MIB_get_ifType (pointer interface) {return ((IP_IF_PTR)interface)->SNMP_IF_TYPE;}
uint_32 MIB_get_ifMtu  (pointer interface) {return ((IP_IF_PTR)interface)->MTU;}

uint_32 MIB_get_ifSpeed (pointer interface)
{ /* Body */
   switch (((IP_IF_PTR)interface)->SNMP_IF_TYPE) {
   case IPIFTYPE_ETHERNET:     return 10000000;
   case IPIFTYPE_FASTETHERNET: return 100000000;
   default:                    return 0;
   } /* Endswitch */
} /* Endbody */

uchar_ptr MIB_get_ifPhysAddress (pointer interface, uint_32 _PTR_ len)
{ /* Body */
   *len = ((IP_IF_PTR)interface)->DEV_ADDRLEN;
   return ((IP_IF_PTR)interface)->DEV_ADDR;
} /* Endbody */

uint_32 MIB_get_ifInOctets      (pointer interface) {return ((IP_IF_PTR)interface)->STATS.ST_RX_OCTETS;}
uint_32 MIB_get_ifInUcastPkts   (pointer interface) {return ((IP_IF_PTR)interface)->STATS.ST_RX_UNICAST;}
uint_32 MIB_get_ifInNUcastPkts  (pointer interface) {return ((IP_IF_PTR)interface)->STATS.ST_RX_MULTICAST + ((IP_IF_PTR)interface)->STATS.ST_RX_BROADCAST;}
uint_32 MIB_get_ifInDiscards    (pointer interface) {return ((IP_IF_PTR)interface)->STATS.ST_RX_MISSED;}
uint_32 MIB_get_ifInErrors      (pointer interface) {return ((IP_IF_PTR)interface)->STATS.ST_RX_ERRORS;}
uint_32 MIB_get_ifOutOctets     (pointer interface) {return ((IP_IF_PTR)interface)->STATS.ST_TX_OCTETS;}
uint_32 MIB_get_ifOutUcastPkts  (pointer interface) {return ((IP_IF_PTR)interface)->STATS.ST_TX_UNICAST;}
uint_32 MIB_get_ifOutNUcastPkts (pointer interface) {return ((IP_IF_PTR)interface)->STATS.ST_TX_MULTICAST + ((IP_IF_PTR)interface)->STATS.ST_TX_BROADCAST;}
uint_32 MIB_get_ifOutDiscards   (pointer interface) {return ((IP_IF_PTR)interface)->STATS.ST_TX_MISSED;}
uint_32 MIB_get_ifOutErrors     (pointer interface) {return ((IP_IF_PTR)interface)->STATS.ST_TX_ERRORS;}

RTCSMIB_NODE_PTR MIB_get_ifSpecific (pointer interface)
{ /* Body */
   switch (((IP_IF_PTR)interface)->SNMP_IF_TYPE) {
   default: return NULL;
   } /* Endswitch */
} /* Endbody */

boolean MIB_find_ifEntry
   (
      uint_32        op,
      pointer        index,
      pointer _PTR_  instance
   )
{ /* Body */
   uint_32           ifindex = *(uint_32_ptr)index;
   pointer           interface;

   if ((op == RTCSMIB_OP_GETNEXT) && (ifindex == 0)) {
      ifindex = 1;
   } /* Endif */

   interface = MIB_get_ifif(ifindex);
   if (!interface) {
      return FALSE;
   } /* Endif */
   *(uint_32_ptr)index = ifindex;
   *instance = interface;
   return TRUE;

} /* Endbody */

uint_32 MIB_set_ifAdminStatus (pointer dummy, uchar_ptr varptr, uint_32 varlen)
{ /* Body */
   /* CR 850 */
   int_32 varval = RTCSMIB_int_read(varptr, varlen);
   /* End CR 850 */
   switch (varval) {
   case 1:  return SNMP_ERROR_noError;
   case 2:
   case 3:  return SNMP_ERROR_inconsistentValue;
   default: return SNMP_ERROR_wrongValue;
   } /* Endswitch */
} /* Endbody */

uint_32 MIB_get_ipForwarding (pointer dummy) {return _IP_forward ? 1 : 2;}

uint_32 MIB_get_ipDefaultTTL (pointer dummy)
{ /* Body */
   IP_CFG_STRUCT_PTR IP_cfg_ptr = RTCS_getcfg(IP);
   return IP_cfg_ptr->DEFAULT_TTL;
} /* Endbody */

uchar_ptr MIB_get_ipAdEntAddr (pointer ipaddr, uint_32 _PTR_ len)
{ /* Body */
   IP_ROUTE_DIRECT_PTR ipaddr_ptr = ipaddr;
   htonl(IpAddress, ipaddr_ptr->ADDRESS);
   *len = 4;
   return IpAddress;
} /* Endbody */

uint_32 MIB_get_ipAdEntIfIndex (pointer ipaddr)
{ /* Body */
   IP_ROUTE_DIRECT_PTR ipaddr_ptr = ipaddr;
   return MIB_get_ifIndex(ipaddr_ptr->NETIF);
} /* Endbody */

uchar_ptr MIB_get_ipAdEntNetMask (pointer ipaddr, uint_32 _PTR_ len)
{ /* Body */
   IP_ROUTE_DIRECT_PTR ipaddr_ptr = ipaddr;
   _ip_address         netmask;

   if (IP_get_netmask(ipaddr_ptr->NETIF, ipaddr_ptr->ADDRESS, &netmask)) {
      htonl(IpAddress, netmask);
      *len = 4;
      return IpAddress;
   } /* Endif */

   htonl(IpAddress, 0xFFFFFFFF);
   *len = 4;
   return IpAddress;
} /* Endbody */

struct MIB_get_ipRouteDest_struct {
   _ip_address             netaddr;
   _ip_address             netmask;
   pointer                 iproute;
};

boolean MIB_get_ipRouteDest_test
   (
      _ip_address    node_ip,
      _ip_address    node_mask,
      pointer        node_data,
      pointer        data
   )
{ /* Body */
   struct MIB_get_ipRouteDest_struct _PTR_   testdata = data;
   IP_ROUTE_PTR                              route = node_data;
   IP_ROUTE_INDIRECT_PTR                     indirect;
   IP_ROUTE_DIRECT_PTR                       direct;

   if (route && route->DIRECT) {
      direct = route->DIRECT;
      do {
         if (direct == testdata->iproute) {
            testdata->netaddr = route->NODE.IP;
            testdata->netmask = route->NODE.MASK;
            return TRUE;
         } /* Endif */
         direct = direct->NEXT;
      } while (direct != route->DIRECT);
   } /* Endif */

   if (route && route->INDIRECT) {
      indirect = route->INDIRECT;
      do {
         if (indirect == testdata->iproute) {
            testdata->netaddr = route->NODE.IP;
            testdata->netmask = route->NODE.MASK;
            return TRUE;
         } /* Endif */
         indirect = indirect->NEXT;
      } while(indirect != route->INDIRECT);
   } /* Endif */

   return FALSE;
} /* Endbody */


uchar_ptr MIB_get_ipRouteDest (pointer iproute, uint_32 _PTR_ len)
{ /* Body */
   IP_CFG_STRUCT_PTR                   IP_cfg_ptr = RTCS_getcfg(IP);
   struct MIB_get_ipRouteDest_struct   testdata;

   testdata.netaddr = INADDR_ANY;
   testdata.iproute = iproute;

   IPRADIX_walk(&IP_cfg_ptr->ROUTE_ROOT.NODE, MIB_get_ipRouteDest_test, &testdata);

   htonl(IpAddress, testdata.netaddr);
   *len = 4;
   return IpAddress;
} /* Endbody */


uint_32 MIB_get_ipRouteIfIndex (pointer iproute)
{ /* Body */
   IP_ROUTE_DIRECT_PTR                    direct = iproute;
   IP_ROUTE_INDIRECT_PTR                  indirect = iproute;
   IP_IF_PTR                              ip_interface;
   _ip_address                            if_ip;

   /* If it is a directly connected route */
   if (((IP_ROUTE_INDIRECT_PTR) iproute)->IS_DIRECT) {
      return MIB_get_ifIndex(direct->NETIF);
   } /* Endif */

   /* If it is an indirectly connected route */
   if_ip = IP_route_find(indirect->GATEWAY, IPROUTEOPT_GATE);
   if (if_ip != INADDR_ANY) {
      ip_interface = IP_find_if(if_ip);
      if (ip_interface) {
         return MIB_get_ifIndex(ip_interface);
      } /* Endif */
   } /* Endif */

   return 0;

} /* Endbody */


uchar_ptr MIB_get_ipRouteNextHop (pointer iproute, uint_32 _PTR_ len)
{ /* Body */
   IP_ROUTE_INDIRECT_PTR iproute_ptr = iproute;
   htonl(IpAddress, iproute_ptr->GATEWAY);
   *len = 4;
   return IpAddress;
} /* Endbody */

uint_32 MIB_get_ipRouteType (pointer iproute)
{ /* Body */
   IP_ROUTE_INDIRECT_PTR iproute_ptr = iproute;
   if (iproute_ptr->IS_DIRECT)   return 3;
   else                          return 4;
} /* Endbody */

uchar_ptr MIB_get_ipRouteMask (pointer iproute, uint_32 _PTR_ len)
{ /* Body */
   IP_CFG_STRUCT_PTR                   IP_cfg_ptr = RTCS_getcfg(IP);
   struct MIB_get_ipRouteDest_struct   testdata;

   testdata.netmask = INADDR_ANY;
   testdata.iproute = iproute;

   IPRADIX_walk(&IP_cfg_ptr->ROUTE_ROOT.NODE, MIB_get_ipRouteDest_test, &testdata);

   htonl(IpAddress, testdata.netmask);
   *len = 4;
   return IpAddress;
} /* Endbody */

uint_32 MIB_get_ipNetToMediaIfIndex (pointer arp)
{ /* Body */
   ARP_ENTRY_PTR arp_ptr = arp;
   return MIB_get_ifIndex(arp_ptr->HEAD);
} /* Endbody */

uchar_ptr MIB_get_ipNetToMediaPhysAddress (pointer arp, uint_32 _PTR_ len)
{ /* Body */
   ARP_ENTRY_PTR arp_ptr = arp;
   *len = 6;
   return arp_ptr->LADDR;
} /* Endbody */

uchar_ptr MIB_get_ipNetToMediaNetAddress (pointer arp, uint_32 _PTR_ len)
{ /* Body */
   ARP_ENTRY_PTR arp_ptr = arp;
   htonl(IpAddress, arp_ptr->PADDR);
   *len = 4;
   return IpAddress;
} /* Endbody */

struct MIB_find_ipAddrEntry_struct {
   _ip_address             addr;
   IP_ROUTE_DIRECT_PTR     direct;
   _ip_address             netaddr;
   IP_IF_PTR               localhost;
};

boolean MIB_find_ipAddrEntry_test
   (
      pointer        node_data,
      pointer        data
   )
{ /* Body */
   struct MIB_find_ipAddrEntry_struct _PTR_  testdata = data;
   IP_ROUTE_PTR                              route = node_data;

   /* Check only leaves, which have a DESTIF of LOCALHOST */
   if (route->DIRECT && route->DIRECT->DESTIF == testdata->localhost) {
      if (route->DIRECT->ADDRESS == testdata->addr) {
         testdata->direct = route->DIRECT;
         return TRUE;
      } /* Endif */
   } /* Endif */

   return FALSE;
} /* Endbody */

boolean MIB_find_ipAddrEntry_walk
   (
      _ip_address    node_ip,
      _ip_address    node_mask,
      pointer        node_data,
      pointer        data
   )
{ /* Body */
   struct MIB_find_ipAddrEntry_struct _PTR_  testdata = data;
   IP_ROUTE_PTR                              route = node_data;

   /* Check only leaves, which have a DESTIF of LOCALHOST */
   if (route && route->DIRECT &&
      route->DIRECT->DESTIF == testdata->localhost)
   {
      if (route->DIRECT->ADDRESS >= testdata->addr) {
         if (testdata->direct == NULL ||
            route->DIRECT->ADDRESS < testdata->direct->ADDRESS)
         {
            testdata->addr = route->DIRECT->ADDRESS;
            testdata->direct = route->DIRECT;
         } /* Endif */
      } /* Endif */
   } /* Endif */

   return FALSE;
} /* Endbody */

boolean MIB_find_ipAddrEntry
   (
      uint_32        op,
      pointer        index,
      pointer _PTR_  instance
   )
{ /* Body */
   IP_CFG_STRUCT_PTR                   IP_cfg_ptr = RTCS_getcfg(IP);
   struct MIB_find_ipAddrEntry_struct  testdata;

   struct {
      uchar   ipAdEntAddr[4];
   } _PTR_ realindex = index;

   testdata.addr        = ntohl(realindex->ipAdEntAddr);
   testdata.localhost   = IP_cfg_ptr->IF_LOCALHOST;
   testdata.direct      = NULL;

   switch (op) {
   case RTCSMIB_OP_GET:
   case RTCSMIB_OP_SET:
      IPRADIX_findbest(&IP_cfg_ptr->ROUTE_ROOT.NODE, testdata.addr,
         MIB_find_ipAddrEntry_test, &testdata);
      break;

   case RTCSMIB_OP_GETNEXT:
      IPRADIX_walk(&IP_cfg_ptr->ROUTE_ROOT.NODE, MIB_find_ipAddrEntry_walk, &testdata);
      break;
   } /* Endswitch */

   if (!testdata.direct) {
      return FALSE;
   } /* Endif */

   htonl(realindex->ipAdEntAddr, testdata.direct->ADDRESS);
   *instance = testdata.direct;
   return TRUE;

} /* Endbody */

boolean MIB_find_ipRouteEntry_test1
   (
      pointer        node_data,
      pointer        data
   )
{ /* Body */
   struct MIB_find_ipAddrEntry_struct _PTR_  testdata = data;
   IP_ROUTE_PTR                              route = node_data;

   if (route->NODE.IP == testdata->addr) {
      testdata->direct = route->DIRECT;
      if (testdata->direct == NULL) {
         /* Start SPR P122-0266-18 remove all warnings from RTCS code. */
         /* testdata->direct = (IP_ROUTE_DIRECT_PTR)route->INDIRECT; */
         testdata->direct = (IP_ROUTE_DIRECT_PTR)((void _PTR_)route->INDIRECT);
         /* End SPR P122-0266-18 */
         return TRUE;
      } /* Endif */
   } /* Endif */

   return FALSE;
} /* Enbody */

boolean MIB_find_ipRouteEntry_walk1
   (
      _ip_address    node_ip,
      _ip_address    node_mask,
      pointer        node_data,
      pointer        data
   )
{ /* Body */
   struct MIB_find_ipAddrEntry_struct _PTR_  testdata = data;
   IP_ROUTE_PTR                              route = node_data;

   if (route) {
      if (node_ip >= testdata->addr) {
         if (testdata->direct == NULL || node_ip < testdata->netaddr) {
            testdata->netaddr = node_ip;
            testdata->direct = route->DIRECT;
            if (testdata->direct == NULL) {
               /* Start SPR P122-0266-18 remove all warnings from RTCS code. */
               /* testdata->direct = (IP_ROUTE_DIRECT_PTR)route->INDIRECT; */
               testdata->direct =
                  (IP_ROUTE_DIRECT_PTR)((void _PTR_)route->INDIRECT);
               /* End SPR P122-0266-18 */
            } /* Endif */
         }  /* Endif */
      } /* Endif */
   } /* Endif */

   return FALSE;
} /* Endbody */

boolean MIB_find_ipRouteEntry
   (
      uint_32        op,
      pointer        index,
      pointer _PTR_  instance
   )
{ /* Body */
   IP_CFG_STRUCT_PTR                   IP_cfg_ptr = RTCS_getcfg(IP);
   struct MIB_find_ipAddrEntry_struct  testdata;
   struct {
      uchar   ipRouteDest[4];
   } _PTR_ realindex = index;

   testdata.addr = ntohl(realindex->ipRouteDest);
   testdata.direct = NULL;
   testdata.netaddr = INADDR_ANY;

   switch (op) {
   case RTCSMIB_OP_GET:
   case RTCSMIB_OP_SET:
      IPRADIX_findbest(&IP_cfg_ptr->ROUTE_ROOT.NODE, testdata.addr,
         MIB_find_ipRouteEntry_test1, &testdata);
      break;

   case RTCSMIB_OP_GETNEXT:
      IPRADIX_walk(&IP_cfg_ptr->ROUTE_ROOT.NODE, MIB_find_ipRouteEntry_walk1, &testdata);
      break;
   } /* Endswitch */

   if (!testdata.direct) {
      return FALSE;
   } /* Endif */

   htonl(realindex->ipRouteDest, testdata.netaddr);
   *instance = testdata.direct;
   return TRUE;

} /* Endbody */

boolean MIB_find_ipNetToMediaEntry
   (
      uint_32        op,
      pointer        index,
      pointer _PTR_  instance
   )
{ /* Body */
   IP_IF_PTR         interface;
   ARP_CFG_PTR       arp_cfg_ptr;
   ARP_ENTRY_PTR     arp_ptr, search_ptr;
   uint_32           ifindex, maxindex, arphash;
   _ip_address       netaddr;
   struct {
      uint_32 ipNetToMediaIfIndex;
      uchar   ipNetToMediaNetAddress[4];
   } _PTR_ realindex = index;

   ifindex = realindex->ipNetToMediaIfIndex;
   netaddr = ntohl(realindex->ipNetToMediaNetAddress);
   maxindex = MIB_get_ifNumber(NULL);

   arp_ptr = NULL;
   switch (op) {
   case RTCSMIB_OP_GET:
   case RTCSMIB_OP_SET:
      interface = MIB_get_ifif(ifindex);
      if (!interface) {
         return FALSE;
      } /* Endif */
      arp_cfg_ptr = interface->ARP;
      if (!arp_cfg_ptr) {
         return FALSE;
      } /* Endif */
      for (arp_ptr = arp_cfg_ptr->CACHE[ARPCACHE_HASH(netaddr)];
           arp_ptr;
           arp_ptr = arp_ptr->NEXT) {
         if (arp_ptr->PADDR == netaddr) {
            break;
         } /* Endif */
      } /* Endfor */
      break;

   case RTCSMIB_OP_GETNEXT:
      for (; ifindex <= maxindex; ifindex++) {
         interface = MIB_get_ifif(ifindex);
         if (!interface) {
            continue;
         } /* Endif */
         arp_cfg_ptr = interface->ARP;
         if (!arp_cfg_ptr) {
            continue;
         } /* Endif */

         for (arphash = 0; arphash < ARPCACHE_SIZE; arphash++) {
            for (search_ptr = arp_cfg_ptr->CACHE[arphash];
                 search_ptr;
                 search_ptr = search_ptr->NEXT) {
               if (search_ptr->PADDR >= netaddr) {
                  if (arp_ptr == NULL) {
                     arp_ptr = search_ptr;
                  } else if (search_ptr->PADDR < arp_ptr->PADDR) {
                     arp_ptr = search_ptr;
                  } /* Endif */
               } /* Endif */
            } /* Endfor */
         } /* Endfor */

         if (arp_ptr) {
            break;
         } /* Endif */

      } /* Endfor */
      break;

   } /* Endswitch */

   if (!arp_ptr) {
      return FALSE;
   } /* Endif */

   realindex->ipNetToMediaIfIndex = ifindex;
   htonl(realindex->ipNetToMediaNetAddress, arp_ptr->PADDR);
   *instance = arp_ptr;
   return TRUE;

} /* Endbody */

uint_32 MIB_set_ipForwarding (pointer dummy, uchar_ptr varptr, uint_32 varlen)
{ /* Body */
   /* CR 850 */
   int_32 varval = RTCSMIB_int_read(varptr, varlen);
   /* End CR 850 */
   switch (varval) {
   case 1: _IP_forward = TRUE;  return SNMP_ERROR_noError;
   case 2: _IP_forward = FALSE; return SNMP_ERROR_noError;
   default: return SNMP_ERROR_wrongValue;
   } /* Endswitch */
} /* Endbody */

uint_32 MIB_set_ipDefaultTTL (pointer dummy, uchar_ptr varptr, uint_32 varlen)
{ /* Body */
   IP_CFG_STRUCT_PTR IP_cfg_ptr = RTCS_getcfg(IP);
   /* CR 850 */
   int_32            varval = RTCSMIB_int_read(varptr, varlen);
   /* End CR 850 */

   if (varval >= 1 && varval <= 255) {
      IP_cfg_ptr->DEFAULT_TTL = varval;
      return SNMP_ERROR_noError;
   } else {
      return SNMP_ERROR_wrongValue;
   } /* Endif */
} /* Endbody */

uint_32 MIB_set_ipRouteDest            (pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}
uint_32 MIB_set_ipRouteIfIndex         (pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}
uint_32 MIB_set_ipRouteMetric1         (pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}
uint_32 MIB_set_ipRouteMetric2         (pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}
uint_32 MIB_set_ipRouteMetric3         (pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}
uint_32 MIB_set_ipRouteMetric4         (pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}
uint_32 MIB_set_ipRouteMetric5         (pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}
uint_32 MIB_set_ipRouteNextHop         (pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}
uint_32 MIB_set_ipRouteType            (pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}
uint_32 MIB_set_ipRouteAge             (pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}
uint_32 MIB_set_ipRouteMask            (pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}
uint_32 MIB_set_ipNetToMediaIfIndex    (pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}
uint_32 MIB_set_ipNetToMediaPhysAddress(pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}
uint_32 MIB_set_ipNetToMediaNetAddress (pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}
uint_32 MIB_set_ipNetToMediaType       (pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}

uint_32 MIB_get_tcpPassiveOpens (pointer dummy)
{ /* Body */
   TCP_CFG_STRUCT_PTR   TCP_cfg_ptr = RTCS_getcfg(TCP);
   TCB_STRUCT_PTR       tcb_ptr;
   uint_32              var;

   var = TCP_cfg_ptr->STATS.ST_CONN_PASSIVE;
   for (tcb_ptr = TCP_cfg_ptr->TCBhead;
        tcb_ptr;
        tcb_ptr = tcb_ptr->next) {
      if (tcb_ptr->state == LISTEN) var--;
   } /* Endfor */
   return var;

} /* Endbody */

uint_32 MIB_get_tcpCurrEstab (pointer dummy)
{ /* Body */
   TCP_CFG_STRUCT_PTR   TCP_cfg_ptr = RTCS_getcfg(TCP);
   TCB_STRUCT_PTR       tcb_ptr;
   uint_32              var;

   var = 0;
   for (tcb_ptr = TCP_cfg_ptr->TCBhead;
        tcb_ptr;
        tcb_ptr = tcb_ptr->next) {
      if (tcb_ptr->state == ESTABLISHED) var++;
   } /* Endfor */
   return var;

} /* Endbody */

uint_32 MIB_get_tcpOutSegs (pointer dummy)
{ /* Body */
   TCP_STATS_PTR TCP_stats_ptr = TCP_stats();
   return TCP_stats_ptr->ST_TX_TOTAL - TCP_stats_ptr->ST_TX_DATA_DUP;
} /* Endbody */

uint_32 MIB_get_tcpConnState (pointer tcb)
{ /* Body */
   switch (((TCB_STRUCT_PTR)tcb)->state) {
   case LISTEN:         return 2;
   case SYN_SENT:       return 3;
   case SYN_RECEIVED:   return 4;
   case ESTABLISHED:    return 5;
   case FINWAIT_1:      return 6;
   case FINWAIT_2:      return 7;
   case CLOSE_WAIT:     return 8;
   case LAST_ACK:       return 9;
   case CLOSING:        return 10;
   case TIME_WAIT:      return 11;
   default:             return 1;
   } /* Endswitch */
} /* Endbody */

uchar_ptr MIB_get_tcpConnLocalAddress (pointer tcb, uint_32 _PTR_ len)
{ /* Body */
   TCB_STRUCT_PTR tcb_ptr = tcb;
   htonl(IpAddress, tcb_ptr->local_host);
   *len = 4;
   return IpAddress;
} /* Endbody */

uint_32 MIB_get_tcpConnLocalPort (pointer tcb)
{ /* Body */
   return ((TCB_STRUCT_PTR)tcb)->local_port;
} /* Endbody */

uchar_ptr MIB_get_tcpConnRemAddress (pointer tcb, uint_32 _PTR_ len)
{ /* Body */
   TCB_STRUCT_PTR tcb_ptr = tcb;
   htonl(IpAddress, tcb_ptr->remote_host);
   *len = 4;
   return IpAddress;
} /* Endbody */

uint_32 MIB_get_tcpConnRemPort (pointer tcb)
{ /* Body */
   return ((TCB_STRUCT_PTR)tcb)->remote_port;
} /* Endbody */

boolean MIB_find_tcpConnEntry
   (
      uint_32        op,
      pointer        index,
      pointer _PTR_  instance
   )
{ /* Body */
   TCP_CFG_STRUCT_PTR   TCP_cfg_ptr = RTCS_getcfg(TCP);
   TCB_STRUCT_PTR       tcb_ptr, search_ptr;
   _ip_address          locaddr, remaddr;
   uint_16              locport, remport;
   struct {
      uchar   tcpConnLocalAddress[4];
      uint_32 tcpConnLocalPort;
      uchar   tcpConnRemAddress[4];
      uint_32 tcpConnRemPort;
   } _PTR_ realindex = index;

   locaddr = ntohl(realindex->tcpConnLocalAddress);
   locport = realindex->tcpConnLocalPort;
   remaddr = ntohl(realindex->tcpConnRemAddress);
   remport = realindex->tcpConnRemPort;

   tcb_ptr = NULL;
   switch (op) {
   case RTCSMIB_OP_GET:
   case RTCSMIB_OP_SET:
      for (tcb_ptr = TCP_cfg_ptr->TCBhead;
           tcb_ptr;
           tcb_ptr = tcb_ptr->next) {

         if ((tcb_ptr->local_host  == locaddr)
          && (tcb_ptr->local_port  == locport)
          && (tcb_ptr->remote_host == remaddr)
          && (tcb_ptr->remote_port == remport)) {

            break;
         } /* Endif */
      } /* Endfor */
      break;

   case RTCSMIB_OP_GETNEXT:
      for (search_ptr = TCP_cfg_ptr->TCBhead;
           search_ptr;
           search_ptr = search_ptr->next) {

         if ( (search_ptr->local_host >  locaddr)

          || ((search_ptr->local_host == locaddr)
           && (search_ptr->local_port >  locport))

          || ((search_ptr->local_host  == locaddr)
           && (search_ptr->local_port  == locport)
           && (search_ptr->remote_host >  remaddr))

          || ((search_ptr->local_host  == locaddr)
           && (search_ptr->local_port  == locport)
           && (search_ptr->remote_host == remaddr)
           && (search_ptr->remote_port >= remport)) ) {

            if (tcb_ptr == NULL) {
               tcb_ptr = search_ptr;
            } else if ( (search_ptr->local_host <  tcb_ptr->local_host)

                    || ((search_ptr->local_host == tcb_ptr->local_host)
                     && (search_ptr->local_port <  tcb_ptr->local_port))

                    || ((search_ptr->local_host  == tcb_ptr->local_host)
                     && (search_ptr->local_port  == tcb_ptr->local_port)
                     && (search_ptr->remote_host <  tcb_ptr->remote_host))

                    || ((search_ptr->local_host  == tcb_ptr->local_host)
                     && (search_ptr->local_port  == tcb_ptr->local_port)
                     && (search_ptr->remote_host == tcb_ptr->remote_host)
                     && (search_ptr->remote_port <  tcb_ptr->remote_port)) ) {
               tcb_ptr = search_ptr;
            } /* Endif */
         } /* Endif */
      } /* Endfor */
      break;

   } /* Endswitch */

   if (!tcb_ptr) {
      return FALSE;
   } /* Endif */

   htonl(realindex->tcpConnLocalAddress, tcb_ptr->local_host);
   realindex->tcpConnLocalPort = tcb_ptr->local_port;
   htonl(realindex->tcpConnRemAddress, tcb_ptr->remote_host);
   realindex->tcpConnRemPort = tcb_ptr->remote_port;
   *instance = tcb_ptr;
   return TRUE;

} /* Endbody */

uint_32 MIB_set_tcpConnState(pointer dummy, uchar_ptr varptr, uint_32 varlen) {return SNMP_ERROR_inconsistentValue;}

uint_32 MIB_get_udpInDatagrams (pointer dummy)
{ /* Body */
   UDP_STATS_PTR UDP_stats_ptr = UDP_stats();
   return UDP_stats_ptr->ST_RX_TOTAL - UDP_stats_ptr->ST_RX_DISCARDED;
} /* Endbody */

uint_32 MIB_get_udpInErrors (pointer dummy)
{ /* Body */
   UDP_STATS_PTR UDP_stats_ptr = UDP_stats();
   return UDP_stats_ptr->ST_RX_DISCARDED - UDP_stats_ptr->ST_RX_NO_PORT;
} /* Endbody */

uchar_ptr MIB_get_udpLocalAddress (pointer ucb, uint_32 _PTR_ len)
{ /* Body */
   UCB_STRUCT_PTR ucb_ptr = ucb;
   htonl(IpAddress, ucb_ptr->IPADDR);
   *len = 4;
   return IpAddress;
} /* Endbody */

uint_32 MIB_get_udpLocalPort (pointer ucb)
{ /* Body */
   return ((UCB_STRUCT_PTR)ucb)->PORT;
} /* Endbody */

boolean MIB_find_udpEntry
   (
      uint_32        op,
      pointer        index,
      pointer _PTR_  instance
   )
{ /* Body */
   UDP_CFG_STRUCT_PTR   UDP_cfg_ptr = RTCS_getcfg(UDP);
   UCB_STRUCT_PTR       ucb_ptr, search_ptr;
   _ip_address          locaddr;
   uint_16              locport;
   struct {
      uchar   udpLocalAddress[4];
      uint_32 udpLocalPort;
   } _PTR_ realindex = index;

   locaddr = ntohl(realindex->udpLocalAddress);
   locport = realindex->udpLocalPort;

   ucb_ptr = NULL;
   switch (op) {
   case RTCSMIB_OP_GET:
   case RTCSMIB_OP_SET:
      RTCS_LIST_SEARCH(UDP_cfg_ptr->OPEN_UCB_HEAD, search_ptr) {
         if ((search_ptr->IPADDR == locaddr)
          && (search_ptr->PORT   == locport)) {
            ucb_ptr = search_ptr;
            break;
         } /* Endif */
      } /* End SEARCH */

      RTCS_LIST_SEARCH(UDP_cfg_ptr->LBOUND_UCB_HEAD, search_ptr) {
         if ((search_ptr->IPADDR == locaddr)
          && (search_ptr->PORT   == locport)) {
            ucb_ptr = search_ptr;
            break;
         } /* Endif */
      } /* End SEARCH */

      RTCS_LIST_SEARCH(UDP_cfg_ptr->BOUND_UCB_HEAD, search_ptr) {
         if ((search_ptr->IPADDR == locaddr)
          && (search_ptr->PORT   == locport)) {
            ucb_ptr = search_ptr;
            break;
         } /* Endif */
      } /* End SEARCH */
      break;
   case RTCSMIB_OP_GETNEXT:
      RTCS_LIST_SEARCH(UDP_cfg_ptr->OPEN_UCB_HEAD, search_ptr) {
         if ((search_ptr->IPADDR >  locaddr)
         || ((search_ptr->IPADDR == locaddr)
          && (search_ptr->PORT   >= locport))) {
            if (ucb_ptr == NULL) {
               ucb_ptr = search_ptr;
            } else if ((search_ptr->IPADDR <  ucb_ptr->IPADDR)
                   || ((search_ptr->IPADDR == ucb_ptr->IPADDR)
                    && (search_ptr->PORT   <  ucb_ptr->PORT))) {
               ucb_ptr = search_ptr;
            } /* Endif */
         } /* Endif */
      } /* End SEARCH */

      RTCS_LIST_SEARCH(UDP_cfg_ptr->LBOUND_UCB_HEAD, search_ptr) {
         if ((search_ptr->IPADDR >  locaddr)
         || ((search_ptr->IPADDR == locaddr)
          && (search_ptr->PORT   >= locport))) {
            if (ucb_ptr == NULL) {
               ucb_ptr = search_ptr;
            } else if ((search_ptr->IPADDR <  ucb_ptr->IPADDR)
                   || ((search_ptr->IPADDR == ucb_ptr->IPADDR)
                    && (search_ptr->PORT   <  ucb_ptr->PORT))) {
               ucb_ptr = search_ptr;
            } /* Endif */
         } /* Endif */
      } /* End SEARCH */

      RTCS_LIST_SEARCH(UDP_cfg_ptr->BOUND_UCB_HEAD, search_ptr) {
         if ((search_ptr->IPADDR >  locaddr)
         || ((search_ptr->IPADDR == locaddr)
          && (search_ptr->PORT   >= locport))) {
            if (ucb_ptr == NULL) {
               ucb_ptr = search_ptr;
            } else if ((search_ptr->IPADDR <  ucb_ptr->IPADDR)
                   || ((search_ptr->IPADDR == ucb_ptr->IPADDR)
                    && (search_ptr->PORT   <  ucb_ptr->PORT))) {
               ucb_ptr = search_ptr;
            } /* Endif */
         } /* Endif */
      } /* End SEARCH */

      break;
   } /* Endswitch */

   if (!ucb_ptr) {
      return FALSE;
   } /* Endif */

   htonl(realindex->udpLocalAddress, ucb_ptr->IPADDR);
   realindex->udpLocalPort = ucb_ptr->PORT;
   *instance = ucb_ptr;
   return TRUE;

} /* Endbody */

uint_32 MIB_set_snmpEnableAuthenTraps
   (
      pointer     dummy,
      uchar_ptr   varptr,
      uint_32     varlen
   )
{ /* Body */
   /* CR 850 */
   int_32 varval = RTCSMIB_int_read(varptr, varlen);
   /* End CR 850 */
   switch (varval) {
   case 1:  return SNMP_ERROR_inconsistentValue;
   case 2:  return SNMP_ERROR_noError;
   default: return SNMP_ERROR_wrongValue;
   } /* Endswitch */
} /* Endbody */

void MIB1213_init(void)
{ /* Body */
   IP_STATS_PTR    IP_stats_ptr   = IP_stats();
   ICMP_STATS_PTR  ICMP_stats_ptr = ICMP_stats();
   TCP_STATS_PTR   TCP_stats_ptr  = TCP_stats();
   UDP_STATS_PTR   UDP_stats_ptr  = UDP_stats();
   SNMP_STATS_PTR  SNMP_stats_ptr = SNMP_get_data();

/* CR 850 */
#define MIB_set_const(var,val) \
   MIBNODE_ ## var.TYPE = RTCSMIB_NODETYPE_UINT_CONST; \
   MIBNODE_ ## var.GET.UINT_CONST = val

#define MIB_set_stat(prot,var,ptr) \
   MIBNODE_ ## var.TYPE = RTCSMIB_NODETYPE_UINT_PTR; \
   MIBNODE_ ## var.GET.UINT_PTR = &prot ## _stats_ptr->ptr

#define MIB_set_ptr(var,type,ptr) \
   MIBNODE_ ## var.TYPE = RTCSMIB_NODETYPE_ ## type ## _PTR; \
   MIBNODE_ ## var.GET.type ## _PTR = ptr

#define MIB_set_fn(var,type) \
   MIBNODE_ ## var.TYPE = RTCSMIB_NODETYPE_ ## type ## _FN; \
   MIBNODE_ ## var.GET.type ## _FN = MIB_get_ ## var

   MIB_set_ptr(   sysDescr,    DISPSTR, (uchar_ptr)SNMPCFG_SYSDESCR );
   MIB_set_ptr(   sysObjectID, OID,     NULL                        );
   MIB_set_fn(    sysUpTime,   UINT                                 );
   MIB_set_ptr(   sysContact,  DISPSTR, NULL                        );
   MIB_set_ptr(   sysName,     DISPSTR, NULL                        );
   MIB_set_ptr(   sysLocation, DISPSTR, NULL                        );
   MIB_set_const( sysServices,          SNMPCFG_SYSSERVICES         );

   MIB_set_fn(    ifNumber,          UINT          );
   MIB_set_fn(    ifIndex,           UINT          );
   MIB_set_ptr(   ifDescr,           DISPSTR, NULL );
   MIB_set_fn(    ifType,            UINT          );
   MIB_set_fn(    ifMtu,             UINT          );
   MIB_set_fn(    ifSpeed,           UINT          );
   MIB_set_fn(    ifPhysAddress,     OCTSTR        );
   MIB_set_const( ifAdminStatus,     1             );
   MIB_set_const( ifOperStatus,      1             );
   MIB_set_const( ifLastChange,      0             );
   MIB_set_fn(    ifInOctets,        UINT          );
   MIB_set_fn(    ifInUcastPkts,     UINT          );
   MIB_set_fn(    ifInNUcastPkts,    UINT          );
   MIB_set_fn(    ifInDiscards,      UINT          );
   MIB_set_fn(    ifInErrors,        UINT          );
   MIB_set_const( ifInUnknownProtos, 0             );
   MIB_set_fn(    ifOutOctets,       UINT          );
   MIB_set_fn(    ifOutUcastPkts,    UINT          );
   MIB_set_fn(    ifOutNUcastPkts,   UINT          );
   MIB_set_fn(    ifOutDiscards,     UINT          );
   MIB_set_fn(    ifOutErrors,       UINT          );
   MIB_set_const( ifOutQLen,         0             );
   MIB_set_fn(    ifSpecific,        OID           );

   MIB_set_fn(       ipForwarding,            UINT                 );
   MIB_set_fn(       ipDefaultTTL,            UINT                 );
   MIB_set_stat( IP, ipInReceives,            ST_RX_TOTAL          );
   MIB_set_stat( IP, ipInHdrErrors,           ST_RX_HDR_ERRORS     );
   MIB_set_stat( IP, ipInAddrErrors,          ST_RX_ADDR_ERRORS    );
   MIB_set_stat( IP, ipForwDatagrams,         ST_RX_FORWARDED      );
   MIB_set_stat( IP, ipInUnknownProtos,       ST_RX_NO_PROTO       );
   MIB_set_stat( IP, ipInDiscards,            ST_RX_MISSED         );
   MIB_set_stat( IP, ipInDelivers,            ST_RX_DELIVERED      );
   MIB_set_stat( IP, ipOutRequests,           ST_TX_TOTAL          );
   MIB_set_stat( IP, ipOutDiscards,           ST_TX_MISSED         );
   MIB_set_const(    ipOutNoRoutes,           0                    );
   MIB_set_const(    ipReasmTimeout,          IPREASM_TTL          );
   MIB_set_stat( IP, ipReasmReqds,            ST_RX_FRAG_RECVD     );
   MIB_set_stat( IP, ipReasmOKs,              ST_RX_FRAG_REASMD    );
   MIB_set_stat( IP, ipReasmFails,            ST_RX_FRAG_DISCARDED );
   MIB_set_stat( IP, ipFragOKs,               ST_TX_FRAG_FRAGD     );
   MIB_set_stat( IP, ipFragFails,             ST_TX_FRAG_DISCARDED );
   MIB_set_stat( IP, ipFragCreates,           ST_TX_FRAG_SENT      );
   MIB_set_fn(       ipAdEntAddr,             OCTSTR               );
   MIB_set_fn(       ipAdEntIfIndex,          UINT                 );
   MIB_set_fn(       ipAdEntNetMask,          OCTSTR               );
   MIB_set_const(    ipAdEntBcastAddr,        1                    );
   MIB_set_const(    ipAdEntReasmMaxSize,     65535                );
   MIB_set_fn(       ipRouteDest,             OCTSTR               );
   MIB_set_fn(       ipRouteIfIndex,          UINT                 );
   MIB_set_const(    ipRouteMetric1,          0                    );
   MIB_set_const(    ipRouteMetric2,          0                    );
   MIB_set_const(    ipRouteMetric3,          0                    );
   MIB_set_const(    ipRouteMetric4,          0                    );
   MIB_set_fn(       ipRouteNextHop,          OCTSTR               );
   MIB_set_fn(       ipRouteType,             UINT                 );
   MIB_set_const(    ipRouteProto,            2                    );
   MIB_set_const(    ipRouteAge,              0                    );
   MIB_set_fn(       ipRouteMask,             OCTSTR               );
   MIB_set_const(    ipRouteMetric5,          0                    );
   MIB_set_ptr(      ipRouteInfo,             OID, NULL            );
   MIB_set_fn(       ipNetToMediaIfIndex,     UINT                 );
   MIB_set_fn(       ipNetToMediaPhysAddress, OCTSTR               );
   MIB_set_fn(       ipNetToMediaNetAddress,  OCTSTR               );
   MIB_set_const(    ipNetToMediaType,        3                    );

   MIB_set_stat( ICMP, icmpInMsgs,           ST_RX_TOTAL       );
   MIB_set_stat( ICMP, icmpInErrors,         ST_RX_DISCARDED   );
   MIB_set_stat( ICMP, icmpInDestUnreachs,   ST_RX_DESTUNREACH );
   MIB_set_stat( ICMP, icmpInTimeExcds,      ST_RX_TIMEEXCEED  );
   MIB_set_stat( ICMP, icmpInParmProbs,      ST_RX_PARMPROB    );
   MIB_set_stat( ICMP, icmpInSrcQuenchs,     ST_RX_SRCQUENCH   );
   MIB_set_stat( ICMP, icmpInRedirects,      ST_RX_REDIRECT    );
   MIB_set_stat( ICMP, icmpInEchos,          ST_RX_ECHO_REQ    );
   MIB_set_stat( ICMP, icmpInEchoReps,       ST_RX_ECHO_REPLY  );
   MIB_set_stat( ICMP, icmpInTimestamps,     ST_RX_TIME_REQ    );
   MIB_set_stat( ICMP, icmpInTimestampReps,  ST_RX_TIME_REPLY  );
   MIB_set_stat( ICMP, icmpInAddrMasks,      ST_RX_INFO_REQ    );
   MIB_set_stat( ICMP, icmpInAddrMaskReps,   ST_RX_INFO_REPLY  );
   MIB_set_stat( ICMP, icmpOutMsgs,          ST_TX_TOTAL       );
   MIB_set_stat( ICMP, icmpOutErrors,        ST_TX_DISCARDED   );
   MIB_set_stat( ICMP, icmpOutDestUnreachs,  ST_TX_DESTUNREACH );
   MIB_set_stat( ICMP, icmpOutTimeExcds,     ST_TX_TIMEEXCEED  );
   MIB_set_stat( ICMP, icmpOutParmProbs,     ST_TX_PARMPROB    );
   MIB_set_stat( ICMP, icmpOutSrcQuenchs,    ST_TX_SRCQUENCH   );
   MIB_set_stat( ICMP, icmpOutRedirects,     ST_TX_REDIRECT    );
   MIB_set_stat( ICMP, icmpOutEchos,         ST_TX_ECHO_REQ    );
   MIB_set_stat( ICMP, icmpOutEchoReps,      ST_TX_ECHO_REPLY  );
   MIB_set_stat( ICMP, icmpOutTimestamps,    ST_TX_TIME_REQ    );
   MIB_set_stat( ICMP, icmpOutTimestampReps, ST_TX_TIME_REPLY  );
   MIB_set_stat( ICMP, icmpOutAddrMasks,     ST_TX_INFO_REQ    );
   MIB_set_stat( ICMP, icmpOutAddrMaskReps,  ST_TX_INFO_REPLY  );

   MIB_set_const(      tcpRtoAlgorithm,     4              );
   MIB_set_const(      tcpRtoMin,           TCP_RTO_MIN    );
   MIB_set_const(      tcpRtoMax,           2 * TCP_MSL    );
   MIB_set_const(      tcpMaxConn,          0              );
   MIB_set_stat(  TCP, tcpActiveOpens,      ST_CONN_ACTIVE );
   MIB_set_fn(         tcpPassiveOpens,     UINT           );
   MIB_set_stat(  TCP, tcpAttemptFails,     ST_CONN_FAILED );
   MIB_set_stat(  TCP, tcpEstabResets,      ST_CONN_RESET  );
   MIB_set_fn(         tcpCurrEstab,        UINT           );
   MIB_set_stat(  TCP, tcpInSegs,           ST_RX_TOTAL    );
   MIB_set_fn(         tcpOutSegs,          UINT           );
   MIB_set_stat(  TCP, tcpRetransSegs,      ST_TX_DATA_DUP );
   MIB_set_fn(         tcpConnState,        UINT           );
   MIB_set_fn(         tcpConnLocalAddress, OCTSTR         );
   MIB_set_fn(         tcpConnLocalPort,    UINT           );
   MIB_set_fn(         tcpConnRemAddress,   OCTSTR         );
   MIB_set_fn(         tcpConnRemPort,      UINT           );

   MIB_set_fn(         udpInDatagrams,  UINT          );
   MIB_set_stat(  UDP, udpNoPorts,      ST_RX_NO_PORT );
   MIB_set_fn(         udpInErrors,     UINT          );
   MIB_set_stat(  UDP, udpOutDatagrams, ST_TX_TOTAL   );
   MIB_set_fn(         udpLocalAddress, OCTSTR        );
   MIB_set_fn(         udpLocalPort,    UINT          );
/* End CR 850 */

   MIB_set_stat( SNMP, snmpInPkts,              ST_RX_TOTAL         );
   MIB_set_stat( SNMP, snmpOutPkts,             ST_TX_TOTAL         );
   MIB_set_stat( SNMP, snmpInBadVersions,       ST_RX_BAD_VERSION   );
   MIB_set_stat( SNMP, snmpInBadCommunityNames, ST_RX_BAD_COMMUNITY );
   MIB_set_const(      snmpInBadCommunityUses,  0                   );
   MIB_set_stat( SNMP, snmpInASNParseErrs,      ST_RX_BAD_PARSE     );
   MIB_set_const(      snmpInTooBigs,           0                   );
   MIB_set_const(      snmpInNoSuchNames,       0                   );
   MIB_set_const(      snmpInBadValues,         0                   );
   MIB_set_const(      snmpInReadOnlys,         0                   );
   MIB_set_const(      snmpInGenErrs,           0                   );
   MIB_set_stat( SNMP, snmpInTotalReqVars,      ST_RX_VAR_GETS      );
   MIB_set_stat( SNMP, snmpInTotalSetVars,      ST_RX_VAR_SETS      );
   MIB_set_stat( SNMP, snmpInGetRequests,       ST_RX_GETREQ        );
   MIB_set_stat( SNMP, snmpInGetNexts,          ST_RX_GETNEXTREQ    );
   MIB_set_stat( SNMP, snmpInSetRequests,       ST_RX_SETREQ        );
   MIB_set_stat( SNMP, snmpInGetResponses,      ST_RX_RESPONSE      );
   MIB_set_stat( SNMP, snmpInTraps,             ST_RX_TRAP          );
   MIB_set_stat( SNMP, snmpOutTooBigs,          ST_TX_TOOBIG        );
   MIB_set_stat( SNMP, snmpOutNoSuchNames,      ST_TX_NOSUCHNAME    );
   MIB_set_stat( SNMP, snmpOutBadValues,        ST_TX_BADVALUE      );
   MIB_set_stat( SNMP, snmpOutGenErrs,          ST_TX_GENERR        );
   MIB_set_stat( SNMP, snmpOutGetRequests,      ST_TX_GETREQ        );
   MIB_set_stat( SNMP, snmpOutGetNexts,         ST_TX_GETNEXTREQ    );
   MIB_set_stat( SNMP, snmpOutSetRequests,      ST_TX_SETREQ        );
   MIB_set_stat( SNMP, snmpOutGetResponses,     ST_TX_RESPONSE      );
   MIB_set_stat( SNMP, snmpOutTraps,            ST_TX_TRAP          );
   MIB_set_const(      snmpEnableAuthenTraps,   2                   );

   RTCSMIB_mib_add(&MIBNODE_mib2);

} /* Endbody */

/* EOF */
